HashMap：
    常问：1.7头插法；1.8尾插法；1.7就是把链表头部元素放在新数组里面，然后再放next。尾部插入就先把最后的节点放入。
    头插法：创建一个新数组，容量为旧容量的两倍。然后遍历table，e.next = newTable[i];  newTable[i] = e;
    尾插法：创建一个新数组，容量为旧容量的两倍。然后 table = newTab; 现在table中都是空的。当 newTab[i] = e

	1.hashMap是key-value形式的散列集合，允许空值和空键，无序、散列表，。jdk1.8之前采用 数组+链表实现，存储的是Node元素。jdk1.8以及之后采用的是 数组+链表+红黑树

	2.在hashMap初始化的时候，有两个重要参数：初始化容量(默认16)，装载因子(默认0.75)。容量是表示数组的长度，当hashMap中的条目数超过 装载因子 * 容量的时候，就会进行扩容。新容量变成原来的两倍。
	
	3.put：检查table数组是否为null(为null进行初始化)，通过key的 (hashCode值 ^ (hashCode值>>>16) 得到的hash值) 和(容量-1)进行 & 操作，找到对应的数组下标。如果对应位置不存在节点，放入节点，最后判断元素的个数size和阈值进行的大小，检查是否需要扩容。如果对应位置存在节点，先检查是否是同一个key(先判断key==，再判断equals)，是的话覆盖旧值；不是的话，再判断该位置的节点是否是 TreeNode(树的插入，或者替换)。都不是的话(Node链表)，进行插入或者替换，再判断链表中节点的个数(大于8个)，如果大于(再判断容量和64比较，决定是扩容，还是转成树)。最后if (++size > threshold)是否扩容(可能造成树退化成链表)，找到最后面一段位置变动相同的头节点。
	
	4.get：通过key的 (hashCode值 ^ (hashCode值>>>16) 得到的hash值) 和(容量-1)进行 & 操作，找到对应的数组下标，拿到对应的Node检查Node的key是否和传入的一致(==,equals)是就返回。不是，再检查当前节点Node是否是TreeNode(是，进行树的查找)。否则就是链表查找。
	

ConcurrentHashMap：
	1.相当于HashMap的多线程实现，
		compareAndSwapInt方法：
			参数：
			1.当前实例
			2.实例变量的内存地址偏移量
			3.预期的旧值
			4.要更新的新值
		compareAndSwapObject方法
			参数：
			1.当前实例
			2.实例变量的内存地址偏移量
			3.预期的旧值
			4.要更新的新值
	
	2.put：检查table数组是否为null(为null进行初始化，通过compareAndSwapInt方法把sizeCtl修改为-1，初始化table数组，再把sizeCtl修改为12(容量-容量>>>2) )，通过key的 (hashCode值 ^ (hashCode值>>>16) 得到的hash值) 和(容量-1)进行 & 操作，找到对应的数组下标。获取到下标位置的元素检查是否为null，如果为null，然后通过compareAndSwapObject修改对应内存地址上的值(修改成功break，失败的话说明其他线程在操作，再次自旋)。对应位置Node不为null，获取hash值和-1比较(等于，帮助扩容helpTransfer方法)。不等于，加入同步代码块(synchronized锁住头元素--table里面的元素)，在通过tabAt()获取头元素(读这个操作保证了可见性，从硬件层面说，就是加了load屏障。)，查看是否等于 synchronized锁住的头元素(双重检查)，后面就会hashMap里面的添加差不多了(添加、更新(key相同)元素到链表、到树、或者扩容)。就是树节点变成了TreeBin。
	
	3.get：和HashMap没什么区别，就是获取头元素的时候采用了，tabAt()获取头元素(读这个操作保证了可见性，从硬件层面说，就是加了load屏障。)。
	
	
CAS锁：比较交换，java里面通过unsafe类去实现调用，是cpu上的原子指令，实现方式基于硬件平台的汇编指令。cpu通过 总线锁、缓存锁 来保证原子性。

AQS锁：aqs是AbstractQueuedSynchronizer抽象类相当于一个模板类，提供一个先进先出等待队列的阻塞锁和相关同步器。具体实现有 ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch。
	属性：
	    Node head
	    Node tail

	举例：
	ReentrantLock里面的FairSync(公平同步)、NonfairSync(非公平同步锁，默认使用)，

	Node 节点属性：
	    pre
	    next
	    waitStatus
	    thread

	形成的样子
	AQS
	head(pre->自己) --> Node --> Node <---tail(next->null)
	                        <--


	lock()：方法获取锁
	使用compareAndSetState将state修改为1，成功相当于获取到锁，并且设置锁拥有线程为当前线程。修改1失败，再次尝试tryAcquire(1)(可能修改的失败之后的一瞬间，有锁释放，所以再次调用tryAcquire(1)进行尝试，但是会先判断state是否为0)；公平下：查看有其他线程比我等待时间长吗(长，就不再尝试修改state)?；非公平下，再次尝试修改state。如果都没成功，然后调用acquireQueued方法，再调addWaiter加入同步队列(cas原子操作)。后面操作就是acquireQueued方法进行，自旋获取prev节点，判断是否是head节点，不是则park(操作系统上的阻塞)；是头节点，再次尝试修改state，如果修改不成功，则进行头节点.prev还是自己，再次自旋修改状态state。
	
	unlock()：释放锁。
	没有公平、非公平之分。对当前state进行 减一 ，然后判断state是否为0，是则，把锁的拥有者线程设置为null，返回true，进行唤醒头节点的next，unPark head的next操作；不为0，说明拥有锁的线程加了多次锁，这个时候次数减一了，但是锁的拥有线程不设置为null，且返回false。
	
线程池：new ThreadPoolExecutor(int corePoolSize,
                                     int maximumPoolSize,
                                     long keepAliveTime,
                                     TimeUnit unit,
                                     BlockingQueue<Runnable> workQueue,
                                     ThreadFactory threadFactory,
                                     RejectedExecutionHandler handler);
        allowCoreThreadTimeOut(true)：设置是否允许核心线程超时。

	相对于自己创建线程的优势：
	1.降低线程创建和销毁的线程的资源消耗，提高了响应速度(免去了创建、销毁时间)
	2.统一管理的线程
	
	执行流程：
	1.当一个任务提交时
	2.如果当前执行线程数小于核心线程数，就创建新线程开始执行任务。
	3.如果当前执行线程数不小于核心线程数，把当前任务加入任务队列。
	4.如果当前执行线程数 >= 核心线程数，且 任务队列也满了。再看最大线程数，小于 则创建新线程执行任务。
	5.当前执行线程数 >= 核心线程数，且 任务队列也满了 且 当前线程 == 最大线程数，执行拒绝策略。
	
	拒绝策略：
	线程里面提供的
	1.AbortPolicy：抛出异常(RejectedExecutionException)
	2.DiscardPolicy：直接丢弃任务
	3.DiscardOldestPolicy：丢弃任务队列中比较久的任务
	4.CallerRunsPolicy：使用调用者线程执行
	还可以实现：RejectedExecutionHandler接口进行自定义的拒绝策略
	
	参数解析：
	corePoolSize：保留在池中的线程数，即使它们处于空闲状态。除非设置了allowCoreThreadTimeOut为true。
	maximumPoolSize：池中允许的最大线程数。
	keepAliceTime：当线程数大于核心线程数时，这时候空闲的线程，将在终止前等待新任务的最长存活时间。
	unit：keepAliveTime参数的时间单位。
	workQueue：在执行任务之前用于保留任务的队列。
	threadFactory：线程创建的工厂。
	handler：线程到达最大，任务队列也满了。进行的拒绝处理。

	线程池问题：
	1.使用execute和submit提交任务，如果出现异常，会出现什么情况？
	答：execute执行会直接抛出异常；submit则不会抛出异常，只有在调用get方法获取结果的时候，会抛出。原因，submit执行任务，会将异常捕获，然后放在返回值里面。在调用get获取返回值的时候，判断是否是异常类型，然后抛出。

代理：jdk、cglib
	jdk代理：
	基于反射机制，生成一个实现代理接口的匿名类，然后重写方法，实现方法的增强。
	cglib代理：
	基于继承机制，继承被代理类，所以方法不要申明为final，然后重写父类方法到达增强了类的效果。
	
	性能差异：
	jdk基于反射、cglib基于字节码。第一次生成字节码时间比较长，而多次调用反射也耗时。
	反射调用的次数达到阈值[也就是反射调用的类成为热点时]之后采用字节码的方式。
	
JVM：
	运行时内存区域：
	堆：分为 新生代、老年代。
		新生代：分为 Eden、Survivor(from to) 占比8：1：1。在GC开始的时候，Eden区的存活的对象，会向to(空)进行复制，然而在from区域的会判断，年龄大小和是否要回收。如果年龄不到，复制到to区。然后gc清除所有不存活的对象。而From区则清空，这时from 和to交换身份。所以不管怎样，都保证to区为空。
		老年代：存放生命周期较长的对象。
		
		担保机制：
		当新对象创建，而新生代区放不下，执行担保，把存在新生代的对象放在老年代，为新对象提供空间。不同的垃圾回收器有所不同。
		Minor GC 清理新生代。 Major GC 清理永久代。Full GC 清理整个堆区
	虚拟机栈：线程私有内存区域。
		在方法加入到栈里面进行执行时，会被打成一个栈帧，包括：局部变量表、操作数栈、动态连接、方法出口。
	本地方法栈：
		
	
	方法区：
		java文件编译后（javac），就会形成一份class文件；class文件中包括类的版本、字段、方法、接口等描述信息外，还有一项就是常量池(class文件常量池、运行时常量池)。
		class文件常量池：存放编译器生成的各种字面量和符号引用。
		运行时常量池：JVM在执行某个类的时候，必须经过加载、连接、初始化。而连接又包括验证、准备、解析三阶段。当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中。运行时常量池也是每个类都有的一个。在解析阶段，会把符号引用替换为直接引用。
	程序计数器：
		程序计数器是当前线程正在执行的字节码的地址。程序计数器是线程隔离的，每一个线程在工作的时候都有一个独立的计数器。
	
	双亲委派模型：
	类加载器：
		Bootstrap：加载java_home/lib下的类
		Extension：加载java_home/lib/ext下的类
		Application：自己开发的类

    常说：某个类加载器不能加载 该类时，给父类加载器(这个父类加载器不是通过继承的形式，类似与 类加载器里面有个   属性为parent 引用 高级别的类加载器)
    例子：Application类加载器 里面有个  parent属性 是Extension类加载器。

	判断一个类是否唯一：类加载器和类本身。

	对象布局；对应到jvm中运行时数据区的关系
	一个对象被创建在堆中，对象的结构是：
	1.对象头(8byte或者16byte-->32位和64位操作系统)
	    1.mark word(4字节或者8字节-->32位和64位操作系统)：用于记录锁状态和拥有者，以及年龄和gc标记
	        32位：
	        前25位是对象的HashCode
	        后4位是对象的分代年龄
	        后2位是锁标志位
	        最后1位固定为0
	        32 bits:
              --------
              hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)
              JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)
              size:32 ------------------------------------------>| (CMS free block)
              PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)

	        64位：
	        前25位unused(没有使用)
	        后31位是对象的HashCode
	        后1位cms_free：和cms收集器有关、因为cms算法是标记-清理，内存碎片问题是将不可达对象委会在一个列表free list中，标记是否在列表中。
	        后4位是对象的分代年龄
	        后1位biased_lock 偏向锁标志
	        最后2位lock 锁标志
	        64 bits:
              --------
              unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)
              JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)
              PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)
              size:64 ----------------------------------------------------->| (CMS free block)

              unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)
              JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)
              narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)
              unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)
             [ptr             | 00]  locked             ptr points to real header on stack
             [header      | 0 | 01]  unlocked           regular object header
             [ptr             | 10]  monitor            inflated lock (header is wapped out)
             [ptr             | 11]  marked             used by markSweep to mark an object

	    2.指向类信息的指针(4字节或者8字节-->32位和64位操作系统) --> 对应到方法区里面存入的类信息(字段的访问修饰符号、方法定义信息、方法字节码、常量、静态变量等)的地址
	    3.数组长度(如果该对象是数组对象，则4字节保存长度，否则没有)
	2.实例数据
	3.对齐填充字节

	指针压缩(1.6默认是开启的，关闭-XX:-UseCompressedOops) 注：指针压缩不能压缩mark word，指向非堆（Heap）的对象指针，局部变量、传参、返回值、NULL指针
    由于有对齐填充，则不管什么地址都是以000结尾，这个时候可以把地址值后3去掉补充到，这个时候相当与多了3位，于是：4*8+3=35位；所以有4G*2^3 = 32G 个地址。
    举例 0000 0000 0000 0000 0000 0000 0000 1000 --> (000) 0000 0000 0000 0000 0000 0000 0000 1000 做地址映射


Spring
	1.创建容器：
	ClassPathXmlApplicationContext：是xml方式。
	AnnotationConfigApplicationContext：是注解方式。

	new容器，构造：
		AnnotationConfigApplicationContext应该调用传入Class... annotatedClasses (注解配置类，可以传入多个)对象的构造；
			// 隐式调用父类的无参构造，super()。
				GenericApplicationContext()
					// 隐式调用父类的无参构造，super() --> AbstractApplicationContext()创建一个资源解析器。
					this.beanFactory = new DefaultListableBeanFactory(); --> 创建出一个默认容器。里面设置了一些忽略初始化bean的Class。
			this()
				AnnotatedBeanDefinitionReader --> 6个默认的BeanPostProcessor被注册到beanDefinitionMap：ConfigurationClassPostProcessor(重要的，BeanPostProcessor、BeanFactoryPostProcessor都实现了)
				ClassPathBeanDefinitionScanner --> bean的扫描类
			register()
				用于注册需要初始化的bean --> 放入beanDefinitionMap
			refresh()
				prepareRefresh()
					准备容器：设置开始时间，创建环境变量。
				prepareBeanFactory()
					准备bean工厂的上下文，如设置ClassLoader，以及添加后置处理器：ApplicationContextAwareProcessor、ApplicationListenerDetector、LoadTimeWeaverAwareProcessor
				postProcessBeanFactory()
					给子容器扩展
				invokeBeanFactoryPostProcessors()
					实例化，注册所有 BeanFactoryPostProcessor的bean；
				registerBeanPostProcessors()
					实例化并注册所有 BeanPostProcessor Bean

				finishBeanFactoryInitialization()
					preInstantiateSingletons()
						1.先遍历beanNames，然后通过beanName去beanDefinitionMap获取bean的定义信息。
						2.判断Bean 是否是抽象的、单例的、懒加载的；是否是FactoryBean类型(再判断是否急于初始化)。
						3.再getBean(beanName)
							3.1doGetBean：通过getSingleton(beanName)检查bean是否存在(1.正在创建、已经完成创建)
								getSingleton(beanName, ObjectFactory)真正的单例bean获取。
								createBean()
								doCreatBean()
								createBeanInstance()
								populateBean()
								initializeBean()：执行初始化方法(init())，beanPostProcessor 会进行 前置before方法、后置after方法。
								而代理对象也在initializeBean方法里面的 前置和后置 里面进行代理的。(AspectJAwareAdvisorAutoProxyCreator)


Mybatis
	SqlSessionFactoryBuilder：通过XMLConfigBuilder.parseConfiguration()对config文件进行解析；通过MapperBuilder解析mapper文件XML。统一封装成Configuration对象
	SqlSessionFactory：把Configuration对象设置到里面。通过openSession()获取到SqlSession。
	SqlSession：通过statement，从Configuration里面获取到MappedStatement。然后SqlSession里面的Executor属性通过MappedStatement获取对应的数据执行的Statement，和通过Configuration获取到的sql进行查询数据库操作(中间会把条件组合得到一个缓存key，判断Mybatis缓存里面是否有数据)。


Mysql
	权限表：user、db、table_priv、columns_priv、host
	binlog三种录入格式
		1.statement：每一条会修改的数据的sql都会记录在binlog中。不需要记录每一行的变化，减少日志量，节约io，提高性能。
		2.row：不记录sql语句上下文相关信息，仅保存那条记录被修改。记录单元为每一行的改动。(此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。)
		3.mixed：一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
	存储引擎
		InnoDB
			提供对数据库ACID事务的支持，并且还提供了行级锁、外键约束。
		MyISAM
			不支持事务，也不支持行级锁、外键约束。
		区别和联系							MyISAM									InnoDB
			存储结构						每张表被存放在三个文件：frm-表格		frm-表格式定义、idb-存储数据和索引。
											式定义、MYD-数据文件、MY-索引文件。
			存储空间						MyISAM可被压缩，存储空间较小。			InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
			可移植性、备份及恢复			数据和索引是映射关系，备份方便			通过 mysqldump、binlog、copy file 数据较大时很多慢。
			文件格式
			记录存储顺序					按记录插入顺序保存						按主键大小有序插入
			外键							不支持									支持
			事务							不支持									支持
			锁支持							表级锁定								行级锁定、表级锁定，锁定力度小并发能力高
			Select							MyISAM更优
			Insert、Update、Delete													InnoDB更优
			Select count(*)					myisam更快，因为myisam内部维护了
											一个计数器，可以直接调取。
			索引实现方式					B+树索引，myisam 是堆表					B+树索引，Innodb 是索引组织表
			哈希索引						不支持									支持
			全文索引						支持									支持

    ACID
        A：原子性，整个事务中的所有操作，要么全部完成，要么全部失败。
        C：一致性，整个事务，开始和结束之间，数据库的完整性约束没有被破坏。举例，转账:不管失败还是成功，两个账户的总金额不变。
        I：隔离性，事务之间是隔离的，一个事务不应该影响其他事务的运行效果。
        D：持久性，事务完成后，事务对数据库所做的改变，持久的保存在数据库中。

        怎么保证ACD：使用undo log、redo log。
        怎么保证CI：MVCC机制。

    undo log(文件名ibdata*)
        重做日志，把所有没有commit的事务回滚到事务开始前的状态，系统崩溃时，可能有些事务还没commit，在系统恢复时，通过undo log进行回滚。
        1.undo log用于存放数据修改 被修改前的值，假设把id=2记录的字段name="A"修改为"B"，那边undo log日志就存放name="A"的记录，当修改出现异常，
            可以使用undo log进行实现回滚操作，保证事务的一致性。
        2.为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际是一种Undo 文件组织方式，每个回滚段又有多个undo log slot。

    redo log (文件名ib_flielog*；redo log是innodb引擎层实现的，并不是所有引擎都有。)
        1.每次更新操作都要写入磁盘，然后磁盘要找到对应记录，然后再更新。整个过程io成本、查找成本都很高。解决方案：WAL技术，先写日志，再写磁盘。
        2.redo log的大小是固定的，在mysql中可以通过修改配置参数innodb_log_files_in_group和innodb_log_file_size配置日志文件的数量和每个日志文件的大小。
        3.redo log采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。
        如图：redolog.png
        例子：当一条记录需要更新，InnoDB引擎就会把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB引擎会在适当的时候，
        将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做的。InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的
        大小是1GB，那么总共就可以记录4GB的操作。从头开始写，写到末尾就有回到开头循环写。类似一个环状，有check point、write pos。
        write pos：表示日志当前记录的位置，当ib_logfile_4写满后，会从ib_logfile_1从头开始记录；
        check point：表示将日志记录的修改写进磁盘，完成数据落盘，数据落盘后checkpoint会将日志上的相关记录擦除掉，即 write pos -> check point之间的部分是redo log空着的部分，用于
        记录新的记录；check point -> write pos 之间的部分是redo log待落盘的数据修改记录。当write pos追上check point时，得先停下记录，先推动check point向前Dion给，空出位置记录新的日志。
        有了 redo log，当数据库发生宕机后，可通过redo log将未落盘的数据恢复，即保证已经提交的事务记录不会丢失。


    mvcc

    慢查询日志

    锁

    索引

    主从

    分库分表



Redis
	1.持久化
		RDB
			fork相同子进程，把数据写入到临时文件，当持久化结束，把临时文件替换成上次持久化好的文件。(问题：会有丢失数据的情况)
		AOF
			会将修改数据 命令，同步写入aof文件，当aof文件过大就会进行重写，就是fork子进程，进行读取aof文件，然后写一个临时文件(比如有set k1 vl和del k1、这两条抵消)，最后替换原文件。
	2.集群模式
		主从集群
		    一个主节点进行读写请求，多个从节点(复制主节点数据)进行读请求。出现问题：单点故障，数据重复。
		哨兵集群
		    一个主节点和多个从节点，通过哨兵节点进行监控主机点状态，当主节点单机，可以进行从节点晋升为主节点(选举机制)。但是在选举过程中，整个服务不可用。出现问题：切换主节点会造成一段时间不可用，数据重复。
		cluster集群
		    类似与多个哨兵集群，存储数据的时候，通过key%16384 找到对应槽位，把数据插入。当一个集群挂了，剩余集群还是可以工作。
	3.常见问题
		缓存穿透
			数据库中本来就没有的数据：解决方案，布隆过滤器、存储空数据设置很短的过期时间(防止很多值为null的key存在)。
		缓存击穿
			缓存中不存在的数据，然后有个高并发请求。导致大量请求落到mysql上：解决方案，分布式锁。
		缓存雪崩
			同一时间很多key都失效了，导致大量请求落到mysql上：解决方案，把key过期时间设置为不同时间段。
		数据库和缓存怎么保证一致性
			延时双删：写库前，先删除缓存，再写数据库。休眠一个主从数据延时的时间+(读请求耗时)，然后再次进行删除缓存。会存在一个问题，数据库写成功了，删除缓存失败。定义重试策略。
	4.单线程为什么快
		基于内存的读写速度快、单线程减少上下文切换时间、使用多路复用技术，可以处理并发的连接，非阻塞IO内部采用epoll+自己实现的简单事件框架。epoll中的读、写、关闭、连接都转化为事件。
		然后利用多路复用的特性，不在io上浪费一点时间。


MQ：
	好处：异步、解耦、削峰填谷
	造成的问题：消息重复消费、消息丢失、甚至消息顺序性的问题。

	解决方案
	消息丢失：主要分为，生产端丢数据、MQ丢数据、消费端丢数据。
	生产端丢数据：
		使用事务消息，生产者开起，MQ没有收到的话会发送一个异常，收到则提交事务，性能低。主流通过Confirm机制，每次写消息分配一个唯一id，当MQ收到消息 会发送一ACK 给生产端。如果没有收到，则进行回调nack接口。
	MQ丢数据：
		持久化没成功，mq宕机了。不太可能
	消费端丢数据：
		消费者在代码里面手动ack。
	
	
	
计算机网络、协议相关
    协议分层模型：七层、五层、四层
    OSI：给网络协议分层标准提供理论
    1.物理层
    2.数据链路层
    3.网络层
    4.传输层
    5.会话层
    6.表示层
    7.应用层

    tcp/ip：制定网络协议分层的标准，可以理解为OSI的实现
                            数据包的角度
    1.链路层                 以太网首部；ip首部；tcp首部；[http数据、其他应用层数据]
    2.网络层                 ip首部；tcp首部；[http数据、其他应用层数据]
    3.传输层                 tcp首部；[http数据、其他应用层数据]
    4.应用层                 [http数据、其他应用层数据]

    ip协议：是无连接的协议，不会占用两个通信计算机的通信线路，负责将每个数据包路由到指定计算机。

    传输控制协议tcp简介：
    1.面向连接的、可靠的、基于字节流的传输层通信协议。
    2.将应用层的数据流分割成报文并发送给目标节点的TCP层。
    3.数据包都有序号，对方收到则发送ACK确认，未收到则重传。
    4.使用校验和来检验数据在传输过程中是否有误。

    tcp报文头部结构：
    source port(2字节)             Destination port(2字节)
                sequence Number(4字节)
                Acknowledgment Number(4字节)
    Offset(1字节)    Reserved(1字节)      TCP Flags(cwr、ece、urgent、ack、push、reset、syn、fin)(c e u a p r s f；2字节)     Window(2字节)
    Checksum()                    Urgent Pointer
            TCP Options(variable length、optional)
        user data

    TCP Flags(cwr、ece、urgent、ack、push、reset、syn、fin)介绍
    URG：紧急指针标志
    ACK：确认序号
    psh：push标志
    RST：重置连接标志
    SYN：同步序列号，用于建立连接过程
    FIN：finish标志，用于释放连接。

    window窗口：指滑动窗口的大小，用来告知接收端的缓存大小。
    checksum：接收和发送校验。

        tcp的三次握手：
        client                                          server
    状态syn-sent      --SYN=1，seq=x-->                    listen
      established   <--SYN=1,ACK=1,seq=y,ack=x+1--      syn-rcvd
      established   --ACK=1,seq=x+1,ack=y+1-->          established
                   <----------传输数据----------->

        tcp的四次挥手：
        client                                              server
    状态syn-send      --SYN=1


	
网络IO