HashMap：
	1.hashMap是key-value形式的散列集合，允许空值和空键，无序、散列表，。jdk1.8之前采用 数组+链表实现，存储的是Node元素。jdk1.8以及之后采用的是 数组+链表+红黑树

	2.在hashMap初始化的时候，有两个重要参数：初始化容量(默认16)，装载因子(默认0.75)。容量是表示数组的长度，当hashMap中的条目数超过 装载因子 * 容量的时候，就会进行扩容。新容量变成原来的两倍。
	
	3.put：检查table数组是否为null(为null进行初始化)，通过key的 (hashCode值 ^ (hashCode值>>>16) 得到的hash值) 和(容量-1)进行 & 操作，找到对应的数组下标。如果对应位置不存在节点，放入节点，最后判断元素的个数size和阈值进行的大小，检查是否需要扩容。如果对应位置存在节点，先检查是否是同一个key(先判断key==，再判断equals)，是的话覆盖旧值；不是的话，再判断该位置的节点是否是 TreeNode(树的插入，或者替换)。都不是的话(Node链表)，进行插入或者替换，再判断链表中节点的个数(大于8个)，如果大于(再判断容量和64比较，决定是扩容，还是转成树)。最后if (++size > threshold)是否扩容(可能造成树退化成链表)，找到最后面一段位置变动相同的头节点。
	
	4.get：通过key的 (hashCode值 ^ (hashCode值>>>16) 得到的hash值) 和(容量-1)进行 & 操作，找到对应的数组下标，拿到对应的Node检查Node的key是否和传入的一致(==,equals)是就返回。不是，再检查当前节点Node是否是TreeNode(是，进行树的查找)。否则就是链表查找。
	

ConcurrentHashMap：
	1.相当于HashMap的多线程实现，
		compareAndSwapInt方法：
			参数：
			1.当前实例
			2.实例变量的内存地址偏移量
			3.预期的旧值
			4.要更新的新值
		compareAndSwapObject方法
			参数：
			1.当前实例
			2.实例变量的内存地址偏移量
			3.预期的旧值
			4.要更新的新值
	
	2.put：检查table数组是否为null(为null进行初始化，通过compareAndSwapInt方法把sizeCtl修改为-1，初始化table数组，再把sizeCtl修改为12(容量-容量>>>2) )，通过key的 (hashCode值 ^ (hashCode值>>>16) 得到的hash值) 和(容量-1)进行 & 操作，找到对应的数组下标。获取到下标位置的元素检查是否为null，如果为null，然后通过compareAndSwapObject修改对应内存地址上的值(修改成功break，失败的话说明其他线程在操作，再次自旋)。对应位置Node不为null，获取hash值和-1比较(等于，帮助扩容helpTransfer方法)。不等于，加入同步代码块(synchronized锁住头元素--table里面的元素)，在通过tabAt()获取头元素(读这个操作保证了可见性，从硬件层面说，就是加了load屏障。)，查看是否等于 synchronized锁住的头元素(双重检查)，后面就会hashMap里面的添加差不多了(添加、更新(key相同)元素到链表、到树、或者扩容)。就是树节点变成了TreeBin。
	
	3.get：和HashMap没什么区别，就是获取头元素的时候采用了，tabAt()获取头元素(读这个操作保证了可见性，从硬件层面说，就是加了load屏障。)。
	
	
CAS锁：比较交换，java里面通过unsafe类去实现调用，是cpu上的原子指令，实现方式基于硬件平台的汇编指令。cpu通过 总线锁、缓存锁 来保证原子性。

AQS锁：aqs是AbstractQueuedSynchronizer抽象类相当于一个模板类，提供一个先进先出等待队列的阻塞锁和相关同步器。具体实现有 ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch。
	属性：
	    Node head
	    Node tail

	举例：
	ReentrantLock里面的FairSync(公平同步)、NonfairSync(非公平同步锁，默认使用)，

	Node 节点属性：
	    pre
	    next
	    waitStatus
	    thread

	形成的样子
	AQS
	head(pre->自己) --> Node --> Node <---tail(next->null)
	                        <--


	lock()：方法获取锁
	使用compareAndSetState将state修改为1，成功相当于获取到锁，并且设置锁拥有线程为当前线程。修改1失败，再次尝试tryAcquire(1)(可能修改的失败之后的一瞬间，有锁释放，所以再次调用tryAcquire(1)进行尝试，但是会先判断state是否为0)；公平下：查看有其他线程比我等待时间长吗(长，就不再尝试修改state)?；非公平下，再次尝试修改state。如果都没成功，然后调用acquireQueued方法，再调addWaiter加入同步队列(cas原子操作)。后面操作就是acquireQueued方法进行，自旋获取prev节点，判断是否是head节点，不是则park(操作系统上的阻塞)；是头节点，再次尝试修改state，如果修改不成功，则进行头节点.prev还是自己，再次自旋修改状态state。
	
	unlock()：释放锁。
	没有公平、非公平之分。对当前state进行 减一 ，然后判断state是否为0，是则，把锁的拥有者线程设置为null，返回true，进行唤醒头节点的next，unPark head的next操作；不为0，说明拥有锁的线程加了多次锁，这个时候次数减一了，但是锁的拥有线程不设置为null，且返回false。
	
线程池：new ThreadPoolExecutor(int corePoolSize,
                                     int maximumPoolSize,
                                     long keepAliveTime,
                                     TimeUnit unit,
                                     BlockingQueue<Runnable> workQueue,
                                     ThreadFactory threadFactory,
                                     RejectedExecutionHandler handler);
        allowCoreThreadTimeOut(true)：设置是否允许核心线程超时。

	相对于自己创建线程的优势：
	1.降低线程创建和销毁的线程的资源消耗，提高了响应速度(免去了创建、销毁时间)
	2.统一管理的线程
	
	执行流程：
	1.当一个任务提交时
	2.如果当前执行线程数小于核心线程数，就创建新线程开始执行任务。
	3.如果当前执行线程数不小于核心线程数，把当前任务加入任务队列。
	4.如果当前执行线程数 >= 核心线程数，且 任务队列也满了。再看最大线程数，小于 则创建新线程执行任务。
	5.当前执行线程数 >= 核心线程数，且 任务队列也满了 且 当前线程 == 最大线程数，执行拒绝策略。
	
	拒绝策略：
	线程里面提供的
	1.AbortPolicy：抛出异常(RejectedExecutionException)
	2.DiscardPolicy：直接丢弃任务
	3.DiscardOldestPolicy：丢弃任务队列中比较久的任务
	4.CallerRunsPolicy：使用调用者线程执行
	还可以实现：RejectedExecutionHandler接口进行自定义的拒绝策略
	
	参数解析：
	corePoolSize：保留在池中的线程数，即使它们处于空闲状态。除非设置了allowCoreThreadTimeOut为true。
	maximumPoolSize：池中允许的最大线程数。
	keepAliceTime：当线程数大于核心线程数时，这时候空闲的线程，将在终止前等待新任务的最长存活时间。
	unit：keepAliveTime参数的时间单位。
	workQueue：在执行任务之前用于保留任务的队列。
	threadFactory：线程创建的工厂。
	handler：线程到达最大，任务队列也满了。进行的拒绝处理。
	
代理：jdk、cglib
	jdk代理：
	基于反射机制，生成一个实现代理接口的匿名类，然后重写方法，实现方法的增强。
	cglib代理：
	基于继承机制，继承被代理类，所以方法不要申明为final，然后重写父类方法到达增强了类的效果。
	
	性能差异：
	jdk基于反射、cglib基于字节码。第一次生成字节码时间比较长，而多次调用反射也耗时。
	反射调用的次数达到阈值[也就是反射调用的类成为热点时]之后采用字节码的方式。
	
JVM：
	运行时内存区域：
	堆：分为 新生代、老年代。
		新生代：分为 Eden、Survivor(from to) 占比8：1：1。在GC开始的时候，Eden区的存活的对象，会向to(空)进行复制，然而在from区域的会判断，年龄大小和是否要回收。如果年龄不到，复制到to区。然后gc清除所有不存活的对象。而From区则清空，这时from 和to交换身份。所以不管怎样，都保证to区为空。
		老年代：存放生命周期较长的对象。
		
		担保机制：
		当新对象创建，而新生代区放不下，执行担保，把存在新生代的对象放在老年代，为新对象提供空间。不同的垃圾回收器有所不同。
		Minor GC 清理新生代。 Major GC 清理永久代。Full GC 清理整个堆区
	虚拟机栈：线程私有内存区域。
		在方法加入到栈里面进行执行时，会被打成一个栈帧，包括：局部变量表、操作数栈、动态连接、方法出口。
	本地方法栈：
		
	
	方法区：
		java文件编译后（javac），就会形成一份class文件；class文件中包括类的版本、字段、方法、接口等描述信息外，还有一项就是常量池(class文件常量池、运行时常量池)。
		class文件常量池：存放编译器生成的各种字面量和符号引用。
		运行时常量池：JVM在执行某个类的时候，必须经过加载、连接、初始化。而连接又包括验证、准备、解析三阶段。当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中。运行时常量池也是每个类都有的一个。在解析阶段，会把符号引用替换为直接引用。
	程序计数器：
		程序计数器是当前线程正在执行的字节码的地址。程序计数器是线程隔离的，每一个线程在工作的时候都有一个独立的计数器。
	
	双亲委派模型：
	类加载器：
		Bootstrap：加载java_home/lib下的类
		Extension：加载java_home/lib/ext下的类
		Application：自己开发的类

    常说：某个类加载器不能加载 该类时，给父类加载器(这个父类加载器不是通过继承的形式，类似与 类加载器里面有个   属性为parent 引用 高级别的类加载器)
    例子：Application类加载器 里面有个  parent属性 是Extension类加载器。

	判断一个类是否唯一：类加载器和类本身。
	
Spring
	1.创建容器：
	ClassPathXmlApplicationContext：是xml方式。
	AnnotationConfigApplicationContext：是注解方式。

	new容器，构造：
		AnnotationConfigApplicationContext应该调用传入Class... annotatedClasses (注解配置类，可以传入多个)对象的构造；
			// 隐式调用父类的无参构造，super()。
				GenericApplicationContext()
					// 隐式调用父类的无参构造，super() --> AbstractApplicationContext()创建一个资源解析器。
					this.beanFactory = new DefaultListableBeanFactory(); --> 创建出一个默认容器。里面设置了一些忽略初始化bean的Class。
			this()
				AnnotatedBeanDefinitionReader --> 6个默认的BeanPostProcessor被注册到beanDefinitionMap：ConfigurationClassPostProcessor(重要的，BeanPostProcessor、BeanFactoryPostProcessor都实现了)
				ClassPathBeanDefinitionScanner --> bean的扫描类
			register()
				用于注册需要初始化的bean --> 放入beanDefinitionMap
			refresh()
				prepareRefresh()
					准备容器：设置开始时间，创建环境变量。
				prepareBeanFactory()
					准备bean工厂的上下文，如设置ClassLoader，以及添加后置处理器：ApplicationContextAwareProcessor、ApplicationListenerDetector、LoadTimeWeaverAwareProcessor
				postProcessBeanFactory()
					给子容器扩展
				invokeBeanFactoryPostProcessors()
					实例化，注册所有 BeanFactoryPostProcessor的bean；
				registerBeanPostProcessors()
					实例化并注册所有 BeanPostProcessor Bean

				finishBeanFactoryInitialization()
					preInstantiateSingletons()
						1.先遍历beanNames，然后通过beanName去beanDefinitionMap获取bean的定义信息。
						2.判断Bean 是否是抽象的、单例的、懒加载的；是否是FactoryBean类型(再判断是否急于初始化)。
						3.再getBean(beanName)
							3.1doGetBean：通过getSingleton(beanName)检查bean是否存在(1.正在创建、已经完成创建)
								getSingleton(beanName, ObjectFactory)真正的单例bean获取。
								createBean()
								doCreatBean()
								createBeanInstance()
								populateBean()
								initializeBean()：执行初始化方法(init())，beanPostProcessor 会进行 前置before方法、后置after方法。
								而代理对象也在initializeBean方法里面的 前置和后置 里面进行代理的。


Mybatis
	SqlSessionFactoryBuilder：通过XMLConfigBuilder.parseConfiguration()对config文件进行解析；通过MapperBuilder解析mapper文件XML。统一封装成Configuration对象
	SqlSessionFactory：把Configuration对象设置到里面。通过openSession()获取到SqlSession。
	SqlSession：通过statement，从Configuration里面获取到MappedStatement。然后SqlSession里面的Executor属性通过MappedStatement获取对应的数据执行的Statement，和通过Configuration获取到的sql进行查询数据库操作(中间会把条件组合得到一个缓存key，判断Mybatis缓存里面是否有数据)。


Mysql
	权限表：user、db、table_priv、columns_priv、host
	binlog三种录入格式
		1.statement：每一条会修改的数据的sql都会记录在binlog中。不需要记录每一行的变化，减少日志量，节约io，提高性能。
		2.row：不记录sql语句上下文相关信息，仅保存那条记录被修改。记录单元为每一行的改动。(此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。)
		3.mixed：一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。
	存储引擎
		InnoDB
			提供对数据库ACID事务的支持，并且还提供了行级锁、外键约束。
		MyISAM
			不支持事务，也不支持行级锁、外键约束。
		区别和联系							MyISAM									InnoDB
			存储结构						每张表被存放在三个文件：frm-表格		frm-表格式定义、idb-存储数据和索引。
											式定义、MYD-数据文件、MY-索引文件。
			存储空间						MyISAM可被压缩，存储空间较小。			InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
			可移植性、备份及恢复			数据和索引是映射关系，备份方便			通过 mysqldump、binlog、copy file 数据较大时很多慢。
			文件格式
			记录存储顺序					按记录插入顺序保存						按主键大小有序插入
			外键							不支持									支持
			事务							不支持									支持
			锁支持							表级锁定								行级锁定、表级锁定，锁定力度小并发能力高
			Select							MyISAM更优
			Insert、Update、Delete													InnoDB更优
			Select count(*)					myisam更快，因为myisam内部维护了
											一个计数器，可以直接调取。
			索引实现方式					B+树索引，myisam 是堆表					B+树索引，Innodb 是索引组织表
			哈希索引						不支持									支持
			全文索引						支持									支持


Redis
	1.持久化
		RDB
			fork相同子进程，把数据写入到临时文件，当持久化结束，把临时文件替换成上次持久化好的文件。(问题：会有丢失数据的情况)
		AOF
			会将修改数据 命令，同步写入aof文件，当aof文件过大就会进行重写，就是fork子进程，进行读取aof文件，然后写一个临时文件(比如有set k1 vl和del k1、这两条抵消)，最后替换原文件。
	2.集群模式
		主从集群
		    一个主节点进行读写请求，多个从节点(复制主节点数据)进行读请求。出现问题：单点故障，数据重复。
		哨兵集群
		    一个主节点和多个从节点，通过哨兵节点进行监控主机点状态，当主节点单机，可以进行从节点晋升为主节点(选举机制)。但是在选举过程中，整个服务不可用。出现问题：切换主节点会造成一段时间不可用，数据重复。
		cluster集群
		    类似与多个哨兵集群，存储数据的时候，通过key%16384 找到对应槽位，把数据插入。当一个集群挂了，剩余集群还是可以工作。
	3.常见问题
		缓存穿透
			数据库中本来就没有的数据：解决方案，布隆过滤器、存储空数据设置很短的过期时间(防止很多值为null的key存在)。
		缓存击穿
			缓存中不存在的数据，然后有个高并发请求。导致大量请求落到mysql上：解决方案，分布式锁。
		缓存雪崩
			同一时间很多key都失效了，导致大量请求落到mysql上：解决方案，把key过期时间设置为不同时间段。
		数据库和缓存怎么保证一致性
			延时双删：写库前，先删除缓存，再写数据库。休眠一个主从数据延时的时间+(读请求耗时)，然后再次进行删除缓存。会存在一个问题，数据库写成功了，删除缓存失败。定义重试策略。
	4.单线程为什么快
		基于内存的读写速度快、单线程减少上下文切换时间、使用多路复用技术，可以处理并发的连接，非阻塞IO内部采用epoll+自己实现的简单事件框架。epoll中的读、写、关闭、连接都转化为事件。
		然后利用多路复用的特性，不在io上浪费一点时间。


MQ：
	好处：异步、解耦、削峰填谷
	造成的问题：消息重复消费、消息丢失、甚至消息顺序性的问题。

	解决方案
	消息丢失：主要分为，生产端丢数据、MQ丢数据、消费端丢数据。
	生产端丢数据：
		使用事务消息，生产者开起，MQ没有收到的话会发送一个异常，收到则提交事务，性能低。主流通过Confirm机制，每次写消息分配一个唯一id，当MQ收到消息 会发送一ACK 给生产端。如果没有收到，则进行回调nack接口。
	MQ丢数据：
		持久化没成功，mq宕机了。不太可能
	消费端丢数据：
		消费者在代码里面手动ack。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	