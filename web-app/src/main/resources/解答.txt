1.java事件机制包括哪三部分？分别介绍。
答：事件、事件监听器、事件源；java.util.EventObject、java.util.EventListener、EventSource。
java.util.EventObject：类，一个方法public Object getSource()用来获取事件。
java.util.EventListener：接口，没有任何方法，只作为顶级接口。自己定义一个方法用来实现事件触发的，动作。
EventSource：用来注册监听器，和发布事件。

2.为什么要使用线程池
答：java中每次创建线程、销毁线程都十分消耗计算机的资源。
创建一个线程需要给它分配内存、列入调度、同时在线程切换的时侯还要执行内存换页，
cpu的缓存被清空，切换回对时候还要重新从内存中读取信息，破环了数据的局部性。
不受控风险，每个人都创建线程，当系统运行起来，所有的线程都在疯狂抢占资源。
每次创建线程都需要 调用操作系统内核的api（内核调用），线程什么都干都要占用1M空间。

KLT(Kernel-LevelThread) 内核级别线程：线程的管理的所有工作（创建和销毁）由操作系统内核完成
特点：
    进程中的一个线程被阻塞，内核能调度同一进程的其他线程（就绪态）占有处理器运行
    多处理器环境中，内核能同时调度同一进程的多线程，将这些线程映射到不同的处理器核心上，提高进程的执行效率。
    应用程序线程在用户态运行，线程调度和管理在内核实现。线程调度时，控制权从一个线程改变到另一线程，需要模式切换，系统开销较大。
ULT(User-LevelThread) 用户级别线程：所以线程的创建，消息传递，调度，保存/恢复上下文都有线程库来完成。内核感知不到多线程的存在。内核继续以进程为调度单位，并且给该进程指定一个执行状态（就绪、运行、阻塞等）。
    线程切换不需要内核模式，能节省模式切换开销和内核资源。
    允许进程按照特定的需要选择不同的调度算法来调度线程。调度算法需要自己实现。
    由于其不需要内核进行支持，所以可以跨OS运行。
    不能利用多核处理器有点，OS调度进程，每个进程仅有一个ULT能执行
    一个ULT阻塞，将导致整个进程的阻塞。

组合策略
